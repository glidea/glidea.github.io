{"posts":[{"title":"事务","content":"事务的特性 **原子性：**事务是由一组SQL组成的逻辑处理单元，要么一起成功，要么一起失败。有undo log(逻辑日志)保证 **持久性：**事务一旦提交，最终一定会持久化到硬盘（数据先写到内存），不会因为宕机而丢失。有redo log保证 **隔离性：**保证事务执行时尽可能不受其它事务的影响，事务的隔离分为不同级别 **一致性：**事务执行后的到的是正确的数据状态，完整性约束不被破坏（数据库的各种约束，以及业务完整性），是事务所要追求的目标，是基于其它三点的 事务并发产生的问题 **脏读：**读到别的事务未提交的数据 **不可重复读：**多次查询同一记录得到不同的结果 **幻读：**多次查询某一范围的记录，会凭空出现或消失一些记录 上述问题主要是一个事务的写对另一个事务的读产生的影响 除此之外还有多个事务对同一资源写操作的并发安全问题，此问题通过锁机制解决，与隔离级别无关 为了解决并发读，所设置的隔离级别 **读未提交：**啥隔离措施都没有 **读已提交：**解决脏读。一个事务读取数据时总是读这个数据最近一次被commit的版本 **可重复读：**解决脏读，不可重复读，部分幻读问题。一个事务读取数据时总是读取当前事务第一次查询出的版本（注意是第一次，而不是事务开始时） **串行化：**解决幻读 隔离级别越高，隔离性越强，一致性也因此更好，但是性能就越差 MySQL解决脏读，不可重复读，幻读，用的是MVCC（Multi-Version Concurrency Control） MVCC解决不了的幻读是插入产生主键重复现象，而当前事务查询出该主键并没有被占用 加锁读，MVCC就会失效，从而出现不可重复读，幻读现象 为了解决并发修改，所设置的锁机制 MySQL的锁只有悲观锁，分为读锁和写锁，每种锁又可以细分为行锁和表锁 并发锁队列，读锁不阻塞后头的锁，写锁会阻塞后头。据此可推导出锁的读写规则 执行更新SQL，自动为当前事务拿写锁；执行查询SQL，不会加任何锁，但可以通过for update或lock in share mode 手动加写锁或读锁（用于在应用层实现大粒度的悲观锁） InnoDB中SQL如果用上了索引，加行锁，反之拿表锁 思考题： ​ 哪行锁和表锁的区别是什么？ ​ 如何解决因使用行锁导致的死锁？ ​ 顺序加锁，设置合适的锁超时时间，开死锁检测，尽量晚加锁，金额拆行累加（参考LongAdder） ​ 行锁的间隙锁？ ","link":"https://glidea.github.io/post/h1icQUmLi/"},{"title":"垃圾回收","content":"对象间的四种引用 强引用：只要 GC Roots 强引用的到，就不会被 GC 回收 软引用：某次 GC 后内存还不够，就把只有软引用的 obj 列入再次 GC 的回收范围 弱引用：如果只有软引用，一旦 GC，就会被回收 虚引用：和弱引用一样不会对 obj 的生存时间造成影响。虚引用对象在引用的 obj 被回收的时候，会自动加入引用队列等待扫描线程，从而起到通知系统的作用 软弱引用可以关联引用队列，obj 回收后软弱引用对象会自动加入引用队列，便于回收软弱引用对象 虚引用关联了默认的引用队列 软弱引用可以用于缓存的实现 虚引用的用途之一是 NIO 的实现，通知系统释放 Buffer 对象对应的本地内存 判断对象是否可达 沿着 GC Roots 的强引用链搜索，找不到的都是不可达对象 可以作为 GC Roots 的对象 虚拟机栈中所有栈帧使用到的对象，譬如各个线程的栈使用到的局部变量，方法参数等 被拿来当锁的对象 方法区中类静态属性引用的对象，譬如引用类型的静态变量 Native 方法引用的 Java 对象 异常对象，类加载器，基本类型的 Class 对象 ...... 判断对象是否可以回收 先判断是否可达，不可达的对象还要在看看有没有软引用。 若有软引用，则先不着急回收该对象，在进行一次 GC 后，若空间还不足，再回收 回收算法 标记复制 O(k) 标记存活对象，然后将其复制到另一块内存 优点：快，只需要标记 + 复制 缺点：浪费空间 用途：回收存活率低的新生代 标记清除 O(n) 标记存活对象，然后扫描整个空间，统一回收未被标记的对象 优点：作为老年代回收算法，延迟低 缺点：有内存碎片，吞吐量不行 用途：用于注重延迟的老年代收集器 标记整理 O(n) 标记存活对象，然后扫描整个空间，同时把标记对象往前挪 优点：作为老年代回收算法，吞吐量高 缺点：需要移动对象，并更改引用。速度慢，延迟高 用途：用于注重吞吐量的老年代收集器 标记清除和标记整理结合使用。如 CMS 平时使用标记清除，碎片过多时，采用标记整理 垃圾收集器 Serial / Serial Old 比其他收集器的单线程快 是客户端模式的默认组合（串行） Parallel Scavenge / Parallel Old 注重吞吐量的收集组合，也是 1.8 默认组合 -XX:MaxGCPauseMillis：保证每次 GC 不会超过这个时间，调低会降低新生代空间，增加回收垃圾所需的总时间，从而导致吞吐量下降（控制延迟常数） -XX:GCTimeRatio：设置 GC 时间可占用总时间的最大比率（控制延迟比例） -XX:+UseAdaotiveSizePolicy：让收集器自调节性能参数 ParNew：多线程版本的 Serial CMS 最佳的新生代可用收集器 JDK9 后 ParNew 并入 CMS，但至此 G1 替代 ParNew + CMS 成为首选方案 CMS：响应优先 运作过程 初始标记：标记 GC Roots 能直接关联的对象（耗时很短，只开了单线程） 并发标记：在初始标记的基础上继续标记 重新标记：修正标记，处理在并发标记的时候，先被标记为垃圾，后面重新被引用的情况 并发清除：清理垃圾对象，不需要移动存活对象（并发过程的新对象，默认存活） 缺点 并发期间开启的回收线程数量是 (核心数 + 3) / 4，在核少的服务器上，会挤占过多的 CPU 资源 由于无法处理浮动垃圾，清理前需要预留部分空间，即老年代占用达到预设百分比后就触发 CMS（Old GC），而不是像别的收集器等到快满的时候才收集 如果预留空间无法容纳浮动垃圾（并发失败），则启用 Serial Old，最新版本采用了 Parallel Old 做备胎 由于使用标记 - 清除，当内存碎片太多时，启用 Full GC （为啥不只是 Old GC） 增量更新有 bug，所以在 remark 阶段会重新扫描（那并发标记阶段不是毫无意义了吗，CMS 不是卵用没有？） G1 思考题 怎么解决并发标记时产生的标记错误 卡表什么作用，怎么实现 YGC 在标记过程的剪枝 写屏障和卡表更新的关系 OopMap 与安全区域的关系 ","link":"https://glidea.github.io/post/kRaswf51Z/"},{"title":"内存结构","content":"虚拟机栈和本地方法栈 栈帧的组成 局部变量表：存放方法参数、局部变量 表item可复用（注意对gc的影响） 这玩意是创建时从运行时常量池弄过来的 操作数栈：类似于数据寄存器，存储临时计算结果 动态连接：当前方法所在类在运行时常量池中的引用 The reference points to the constant pool for the class of the method being executed for that frame 方法返回值和返回地址 异常处理表 栈上分配 开启逃逸分析和标量替换后，非逃逸对象可以在栈上分配，但大对象还需要在堆上分配 异常情况 StackOverflow：栈帧太多 OOM：内存不足，无法申请新的栈帧 程序计数器 作用：记住线程下一条 “JVM指令” 的地址（指令在方法区中） 是实现分支、循环、跳转、异常处理的基础设施 以及保存上下文切换的执行进度 补充 JVM的计数器是软件方法实现的，并非物理上的计数器（寄存器） 执行native方法的时候，JVM计数器的值为undefined，下一条指令的地址在物理计数器上 唯一不存在OOM的区域 堆 年轻代与老年代 G1 不再完全基于传统分代模型，而是采用基于 Region 的动态分代策略 ZGC 目前不分代，ZGC 分代实现仍在探索中 StringTable 入池原理 字符串变量拼接原理是StringBuilder //需主动入池 字符串常量拼接原理是编译期优化 //被动入池 被动入池：懒加载 主动入池：str.intern() 1.6中，若StringTable中有str.value，则不放入；若没有，则放入str的副本 1.7以后，直接放入str本体（可能和StringTable从元空间剥离，逻辑上放在了堆上有关） 调优 因为StringTable是哈希表结构，所以可以通过调节桶数量进行调优，桶数量通过虚拟机参数调节 思考题 对象从创建到被回收的过程是怎样的？ 什么是空间担保？ 方法区 The Java Virtual Machine has a method area that is shared among all Java Virtual Machine threads. The method area is analogous to the storage area for compiled code of a conventional language or analogous to the &quot;text&quot; segment in an operating system process. It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors, including the special methods used in class and instance initialization and interface initialization. 组成 类信息：包含类的字段，方法，特殊方法。但注意 Class 对象在堆中 运行时常量池：就是一张数组结构的表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、对象地址等信息 逻辑包含字符串常量池，1.7后StringTable继续待在堆中，方法区别的玩意放到了本地内存的元空间 直接内存 性能好，直接分配在Native堆，减少了Java堆和Native堆之间的copy 参考 https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html https://blog.jamesdbloom.com/JVMInternals.html ","link":"https://glidea.github.io/post/vwp0rgIpw/"}]}