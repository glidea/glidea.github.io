<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://glidea.github.io</id>
    <title>Glidea&apos;s Blog</title>
    <updated>2020-12-28T09:28:59.526Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://glidea.github.io"/>
    <link rel="self" href="https://glidea.github.io/atom.xml"/>
    <subtitle>be static</subtitle>
    <logo>https://glidea.github.io/images/avatar.png</logo>
    <icon>https://glidea.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Glidea&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[JVM - 内存结构]]></title>
        <id>https://glidea.github.io/post/jvm-nei-cun-jie-gou/</id>
        <link href="https://glidea.github.io/post/jvm-nei-cun-jie-gou/">
        </link>
        <updated>2020-12-28T09:27:26.000Z</updated>
        <content type="html"><![CDATA[<h3 id="虚拟机栈和本地方法栈"><strong>虚拟机栈和本地方法栈</strong></h3>
<ul>
<li>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6">栈帧的组成</a></p>
<ul>
<li>
<p>局部变量表：存放方法参数、局部变量</p>
<blockquote>
<p>表item可复用（注意对gc的影响）</p>
<p>这玩意是创建时从运行时常量池弄过来的</p>
</blockquote>
</li>
<li>
<p>操作数栈：类似于数据寄存器，存储临时计算结果</p>
</li>
<li>
<p>动态连接：当前方法所在类在运行时常量池中的引用</p>
<blockquote>
<p>The reference points to the constant pool for the class of the method being executed for that frame</p>
</blockquote>
</li>
<li>
<p>方法返回值和返回地址</p>
</li>
<li>
<p>异常处理表</p>
</li>
</ul>
</li>
<li>
<p>栈上分配</p>
<pre><code>开启逃逸分析和标量替换后，非逃逸对象可以在栈上分配，但大对象还需要在堆上分配
</code></pre>
</li>
<li>
<p>异常情况</p>
<pre><code>StackOverflow：栈帧太多
OOM：内存不足，无法申请新的栈帧
</code></pre>
</li>
</ul>
<h3 id="程序计数器"><strong>程序计数器</strong></h3>
<ul>
<li>
<p>作用：记住线程下一条 “JVM指令” 的地址（指令在方法区中）</p>
<pre><code>是实现分支、循环、跳转、异常处理的基础设施
以及保存上下文切换的执行进度
</code></pre>
</li>
<li>
<p>补充</p>
<pre><code>JVM的计数器是软件方法实现的，并非物理上的计数器（寄存器）
执行native方法的时候，JVM计数器的值为undefined，下一条指令的地址在物理计数器上
唯一不存在OOM的区域
</code></pre>
</li>
</ul>
<h3 id="堆"><strong>堆</strong></h3>
<ul>
<li>
<p>StringTable</p>
<ul>
<li>
<p>入池原理</p>
<blockquote>
<p>字符串变量拼接原理是StringBuilder //需主动入池<br>
字符串常量拼接原理是编译期优化	 //被动入池<br>
被动入池：懒加载<br>
主动入池：str.intern()<br>
1.6中，若StringTable中有str.value，则不放入；若没有，则放入str的副本<br>
1.7以后，直接放入str本体（可能和StringTable从元空间剥离，逻辑上放在了堆上有关）</p>
</blockquote>
</li>
<li>
<p>调优</p>
<blockquote>
<p>因为StringTable是哈希表结构，所以可以通过调节桶数量进行调优，桶数量通过虚拟机参数调节</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="方法区"><strong><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">方法区</a></strong></h3>
<pre><code>The Java Virtual Machine has a method area that is shared among all Java Virtual Machine threads. The method area is analogous to the storage area for compiled code of a conventional language or analogous to the &quot;text&quot; segment in an operating system process. It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors, including the special methods used in class and instance initialization and interface initialization.
</code></pre>
<ul>
<li>
<p>组成</p>
<ul>
<li>
<p>类信息：包含类的字段，方法，特殊方法</p>
</li>
<li>
<p>运行时常量池：就是一张数组结构的表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、对象地址等信息</p>
<blockquote>
<p>逻辑包含字符串常量池，1.7后StringTable继续待在堆中，方法区别的玩意放到了本地内存的元空间</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="直接内存"><strong>直接内存</strong></h3>
<pre><code>性能好，直接分配在Native堆，减少了Java堆和Native堆之间的copy
</code></pre>
<h3 id="参考"><strong>参考</strong></h3>
<ul>
<li>
<p>https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html</p>
</li>
<li>
<p>https://blog.jamesdbloom.com/JVMInternals.html</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统知识点总结 - 3]]></title>
        <id>https://glidea.github.io/post/cao-zuo-xi-tong-zhi-shi-dian-zong-jie-3/</id>
        <link href="https://glidea.github.io/post/cao-zuo-xi-tong-zhi-shi-dian-zong-jie-3/">
        </link>
        <updated>2020-04-27T13:26:33.000Z</updated>
        <content type="html"><![CDATA[<h4 id="一-处理机调度的三个层次">一、处理机调度的三个层次</h4>
<ul>
<li>作业调度：从后备队列中选择合适的作业将其从外存调入内存，并为其创建进程</li>
<li>内存调度：从挂起队列中选择合适的进程将其数据从外存调回内存（内存不足时，某些进程会被挂起到外存）</li>
<li>进程调度：从就绪队列中选择一个进程为其分配处理机</li>
</ul>
<h4 id="二-进程调度">二、进程调度</h4>
<ul>
<li>什么时候需要调度进程
<ul>
<li>运行中的进程主动放弃处理机资源
<ul>
<li>进程正常终止</li>
<li>发生异常终止</li>
<li>主动阻塞（如 等待I / O）</li>
</ul>
</li>
<li>运行中的进程被动放弃处理机资源
<ul>
<li>分配的时间片用完</li>
<li>有更紧急的事（如 I / O中断）</li>
<li>有更高优先级的进程进入就绪队列</li>
</ul>
</li>
</ul>
</li>
<li>什么时候一定不能进行进程调度
<ul>
<li>处理中断的时候</li>
<li>进程在操作系统内核程序临界区中（进程运行到锁里的代码，这时要让进程尽快执行完）</li>
<li>原子操作过程中</li>
</ul>
</li>
<li>进程调度和进程切换
<ul>
<li>狭义进程调度：从就绪队列选择一个要运行的进程</li>
<li>进程切换：保存原来进程的运行环境，恢复新进程的运行环境</li>
<li>广义进程调度：狭义进程调度 + 进程切换</li>
</ul>
</li>
</ul>
<h4 id="三-调度算法的评价指标">三、调度算法的评价指标</h4>
<ul>
<li>CPU利用率：忙碌时间 / 总时间</li>
<li>系统吐出量：完成作业数 / 总时间 （作业完成效率）</li>
<li>周转时间
<ul>
<li>周转时间：作业完成时间 - 作业提交时间 （等待 + 运行）</li>
<li>平均周转时间：各作业周转时间之和 / 作业数</li>
<li>带权周转时间：作业周转时间 / 作业运行时间 （越小越好）</li>
<li>平均带权周转时间：各作业带权周转时间之和 / 作业数</li>
</ul>
</li>
<li>等待时间</li>
<li>响应时间：从用户提交请求到首次产生响应的时间</li>
</ul>
<h4 id="四-调度算法">四、调度算法</h4>
<ul>
<li>先来先服务（FCFS）：只考虑进程的等待时间
<ul>
<li>规则：按照作业 / 进程到达的先后顺序进行服务</li>
<li>是否可抢占：NO</li>
<li>优：公平</li>
<li>缺：短作业 / 进程不爽，自己就是撒泡尿，还要等个拉屎的</li>
</ul>
</li>
<li>短作业优先（SJF）：只考虑进程的运行时间
<ul>
<li>规则：先服务要求服务时间最短的作业 / 进程</li>
<li>是否可抢占：NO or YES</li>
<li>优：“最短的”平均等待 / 周转时间</li>
<li>缺：长作业 / 进程不爽，自己就是拉个屎，撒尿的抢着来</li>
<li>补充：SJF的抢占式版本SRNT算法：只考虑剩余运行时间，优点和缺点都更极端</li>
</ul>
</li>
<li>高响应比优先（HRRN）：考虑了进程的等待和运行时间
<ul>
<li>规则：响应比高的作业 / 进程优先，响应比 =（等待时间+运行时间）/ 运行时间</li>
<li>是否可抢占：NO</li>
<li>优：综合了上述两种算法的优点</li>
</ul>
</li>
<li>时间片轮转（RR）：分时、进程专属版FCFS！
<ul>
<li>规则：大家轮流上3秒厕所</li>
<li>是否可抢占：YES，和涉及到时间片的算法都是抢占式的，屎拉到一半都得夹断出来</li>
<li>优：公平，适用于分时系统</li>
<li>缺：资源开销大，不能处理紧急任务</li>
<li>补充：时间片太大，退化成FCFS；时间片太小，开销太大</li>
</ul>
</li>
<li>优先级调度（有抢占式和非抢占式的）
<ul>
<li>规则：优先调度优先级最高的作业 / 进程</li>
<li>是否可抢占：NO or YES</li>
<li>优：可处理紧急任务，适用于实时系统</li>
</ul>
</li>
<li>多级反馈队列：进程专属的完美算法
<ul>
<li>规则
<ul>
<li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li>
<li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾（如果此时已经是在最下级的队列，则重新放回该队列队尾）</li>
<li>只有第k级队列为空时，才会为k+1级队头的进程分配时间片</li>
</ul>
</li>
<li>是否可抢占：YES</li>
<li>优点
<ul>
<li>对各类型进程相对公平（FCFS的优点）</li>
<li>每个新到达的进程都可以很快就得到响应（RR的优点）</li>
<li>短进程只用较少的时间就可完成（SPF的优点）</li>
<li>不必实现估计进程的运行时间（避免用户作假）</li>
<li>可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I / 0密集型进程（拓展：可以将因I / 0而阻塞的进程重新放回原队列，这样I / 0型进程就可以保持较高优先级）</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统知识点总结 - 2]]></title>
        <id>https://glidea.github.io/post/cao-zuo-xi-tong-zhi-shi-dian-zong-jie-2/</id>
        <link href="https://glidea.github.io/post/cao-zuo-xi-tong-zhi-shi-dian-zong-jie-2/">
        </link>
        <updated>2020-04-21T13:32:54.000Z</updated>
        <content type="html"><![CDATA[<h4 id="一-进程和程序有什么区别">一、进程和程序有什么区别</h4>
<ul>
<li>程序是静态的，是存储在硬盘的可执行文件，是一系列指令的集合</li>
<li>进程是动态的，是存储在内存中的实体，是程序的一次执行过程</li>
</ul>
<h4 id="二-进程的组成">二、进程的组成</h4>
<ul>
<li>PCB：存放操作系统管理进程所需的信息（进程描述信息、进程控制管理信息、资源分配清单、处理机相关信息）
<ul>
<li>PCB是进程存在的唯一标志</li>
</ul>
</li>
<li>程序段：程序代码（指令集合）</li>
<li>数据段：运行过程中所产生的数据（代码中定义的变量）</li>
</ul>
<h4 id="三-进程的特征">三、进程的特征</h4>
<ul>
<li>动态性（基本特征）</li>
<li>独立性（独立获得资源，独立接受调度的基本单位）</li>
<li>并发性</li>
<li>异步性</li>
<li>结构性</li>
</ul>
<h4 id="四-进程的组织方式">四、进程的组织方式</h4>
<ul>
<li>链接方式：按照进程状态将PCB分为多个队列</li>
<li>索引方式：按照进程状态将PCB分为多个索引表</li>
</ul>
<h4 id="五-进程的状态与转换">五、进程的状态与转换</h4>
<ul>
<li>状态：创建、就绪、运行、阻塞、终止</li>
<li>基本状态之间的转换（原语实现转换的过程）
<ul>
<li>就绪 --》运行：进程被调度</li>
<li>运行 --》就绪：时间片用完，或CPU被高优先级进程抢占</li>
<li>运行 --》阻塞：进程用系统调用的方式，申请系统资源，或者请求等待某个事情的发生（比如其它进程的执行结果）</li>
<li>阻塞 --》就绪：资源已经分配，或者等待的事情发生（被动）</li>
</ul>
</li>
</ul>
<h4 id="六-原语实现进程状态转换要干的事情">六、原语实现进程状态转换要干的事情</h4>
<ul>
<li>更新PCB的信息
<ul>
<li>所有进程控制原语一定会修改进程状态标记</li>
<li>剥夺当前运行进程的CPU使用权，要先保存运行环境，相反进程开始运行前，要恢复运行环境</li>
</ul>
</li>
<li>将PCB插入合适的队列</li>
<li>分配 / 回收资源</li>
</ul>
<h4 id="七-进程通信的方式">七、进程通信的方式</h4>
<ul>
<li>共享存储：互斥访问一块共享空间
<ul>
<li>共享存储的实现可以基于存储区或者数据结构</li>
</ul>
</li>
<li>管道通信：互斥访问一个共享文件（缓冲区）
<ul>
<li>一个管道只能实现半双工通信</li>
<li>写满时，不能再写，读空时，不能再读</li>
<li>没写满，不能读，没读空，不能写</li>
</ul>
</li>
<li>消息传递：进程通过发送 / 接收原语来 发送 / 接收结构化的消息（消息头/消息体）
<ul>
<li>直接通信：消息直接挂到接收线程的消息队列里</li>
<li>间接通信：消息发送到公共信箱</li>
</ul>
</li>
</ul>
<h4 id="八-线程和进程">八、线程和进程</h4>
<ul>
<li>多个线程从属于一个进程</li>
<li>线程是处理机调度的单位，进程是资源分配的单位</li>
<li>同一进程内的线程切换不会导致进程的切换，运行环境也就无需改变，系统开销从而降低</li>
</ul>
<h4 id="九-线程的实现方式">九、线程的实现方式</h4>
<ul>
<li>应用通过线程库实现用户级线程并自主管理，操作系统不知道</li>
<li>将m个用户级线程映射到n个内核级线程（多对多模型）</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[三门问题]]></title>
        <id>https://glidea.github.io/post/san-men-wen-ti/</id>
        <link href="https://glidea.github.io/post/san-men-wen-ti/">
        </link>
        <updated>2020-04-19T02:50:36.000Z</updated>
        <content type="html"><![CDATA[<h4 id="一-什么是三门问题">一、什么是三门问题</h4>
<p>​		三门问题出自美国的电视游戏节目Let's Make a Deal。参赛者会看见三扇关闭了的门，其中一扇的后面有一辆汽车，选中后面有车的那扇门可赢得该汽车，另外两扇门后面则各藏有一只山羊。当参赛者选定了一扇门，但未去开启它的时候，节目主持人开启剩下两扇门的其中一扇，露出其中一只山羊。主持人其后会问参赛者要不要换另一扇仍然关上的门。</p>
<p>​		<strong>问题是换门后会不会增加中奖概率？</strong></p>
<h4 id="二-答案是个啥">二、答案是个啥？</h4>
<p>​		相信你直觉上的答案是 “换门不会增加中奖概率”</p>
<p>​		但是<strong>正确答案是换门可以增加中奖概率</strong></p>
<p>​		你是不是觉得这个答案很奇怪，很反直觉，内心有一万个不服？</p>
<p>​		于是你去看了下这个问题的数学证明</p>
<p>​		心想，好像是这样子哦！</p>
<p>​		但是你眉头一皱，总感觉哪里不对劲</p>
<p>​		对数学证明的态度在好像明白和质疑之间反复横跳</p>
<p>​		那既然你对直觉和数学证明都不太相信的话，那我们就用另外的方式去求解一下这个答案！</p>
<h4 id="三-计算机模拟求解的思路">三、计算机模拟求解的思路</h4>
<p>​		用程序怎么解决这个问题呢？</p>
<p>​		直接套概率公式，让计算机给你解计算题？？这样的话不就是相当于我们把上面的正确答案，用计算机复述了一遍吗</p>
<p>​		正确思路是，我们要假设自个参加了一百万次这个节目，并面临了同样的选择，并且并且我一定要换门。看看我这一百万次，能中多少次奖，进而求出换门的中奖率。然后我又参加一百万次，但这一百万次我要坚持不换门，看看我这一百万次，能中多少次奖，进而求出不换门的中奖率。</p>
<p>​		讲到这里思路很明显了，我们要用计算机模拟数百万次这种场景，进而得出答案。</p>
<h4 id="四-计算机模拟的代码">四、计算机模拟的代码</h4>
<pre><code class="language-java">public class Solution {
    private static int N = 100000;// 模拟场景的次数

    // 计算选择N次 换门或者不换门 的整体中奖概率
    private static double getProbability(boolean changeDoor) {
        int winTimeCount = 0;

        for (int i = 0; i &lt; N; i++)
            if (choice(changeDoor))
                winTimeCount++;

        return (double) winTimeCount / N;
    }

    // 模拟 选择换门或者不换门 是否能中奖
    private static boolean choice(boolean changeDoor) {
        int firstChoice = (int) (Math.random() * 3);
        int prizeDoor = (int) (Math.random() * 3);

        // 要理解这里，需要明白，本来只有三个门，主持人已经把一个没有奖品的门给开了
        // 只剩下两个门给你选，如果你本来选的门没有奖品，换门一定拿奖，反之亦然
        if (firstChoice == prizeDoor) {
            return changeDoor ? false : true;
            // 上面的语句可以写成：return !changeDoor;
            // 为了语义清晰，写成了三目表达式的形式，下面else里的return语句也是类似的
        } else {
            return changeDoor ? true : false;
        }
    }

    public static void main(String[] args) {
        System.out.println(&quot;换门 - 中奖的概率：&quot; + getProbability(true));
        System.out.println(&quot;不换门 - 中奖的概率：&quot; + getProbability(false));
    }
}
</code></pre>
<p><strong>运行结果：</strong></p>
<pre><code>换门 - 中奖的概率：0.66731
不换门 - 中奖的概率：0.33346
</code></pre>
<h4 id="五-为什么答案是会增加中奖概率呢">五、为什么答案是会增加中奖概率呢</h4>
<p>​		至此，答案已经很明显了，但是你可能还是不太明白这个答案，所以在此我给出一个不严谨的解释</p>
<p>​		假设选择换门，而现在选择的门后面没有奖品，所以必定中奖（只有一个门可以换）</p>
<p>​		假设选择换门，而现在选择的门后面有奖品，所以必定不中奖</p>
<p>​		而选择的门后没有奖品的概率是2 / 3</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统知识点总结 - 1]]></title>
        <id>https://glidea.github.io/post/cao-zuo-xi-tong-zhi-shi-dian-zong-jie-1/</id>
        <link href="https://glidea.github.io/post/cao-zuo-xi-tong-zhi-shi-dian-zong-jie-1/">
        </link>
        <updated>2020-04-17T12:17:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-操作系统的功能是什么">一、操作系统的功能是什么</h3>
<ul>
<li>管理软硬资源
<ul>
<li>处理机管理</li>
<li>存储器管理</li>
<li>文件管理</li>
<li>设备管理</li>
</ul>
</li>
<li>向上层提供服务
<ul>
<li>向用户提供GUI，单命令（联机命令接口），批处理（脱机命令接口）</li>
<li>向应用程序提供程序接口（系统调用）</li>
</ul>
</li>
<li>对底层功能进行拓展</li>
</ul>
<h3 id="二-操作系统的特征是什么">二、操作系统的特征是什么</h3>
<ul>
<li>并发：一个时间段内，多件事情在宏观上同时发生，在微观上交替发生</li>
<li>共享（并发的条件）
<ul>
<li>互斥共享：一个资源，一个时间段内只允许一个进程访问</li>
<li>同时共享：一个资源，一个时间段内允许多个进程访问</li>
</ul>
</li>
<li>虚拟：一个物理实体（硬盘）--》若干个虚拟逻辑体（C盘、D盘...）</li>
<li>异步：在资源有限的情况下，并发执行的多个程序的执行，总是走走停停的（不按代码的顺序执行）</li>
</ul>
<h3 id="三-操作系统的特征之间的关系">三、操作系统的特征之间的关系</h3>
<ul>
<li>并发和共享互为存在条件
<ul>
<li>没有共享，无法实现并发</li>
<li>没用并发，共享就没有意义</li>
</ul>
</li>
<li>并发和共享是虚拟的前提条件
<ul>
<li>共享是并发的前提，而并发是虚拟性<strong>存在意义的前提</strong></li>
</ul>
</li>
<li>并发和共享必然导致异步</li>
</ul>
<h3 id="四-操作系统的发展背景和分类">四、操作系统的发展背景和分类</h3>
<ul>
<li>手工操作阶段（手工输入一条条指令）
<ul>
<li>缺：人机速度矛盾（人工太tm慢了，机器等得很不耐烦）</li>
</ul>
</li>
<li>批处理阶段
<ul>
<li>单道批处理系统（引入脱机输入输出技术）
<ul>
<li>优：缓解了人机速度矛盾</li>
<li>缺：内存中只有一道程序执行，资源利用率还是很低（每次只有一个进程走流程，没走到的部分只能干等着）</li>
</ul>
</li>
<li>多道批处理系统（操作系统开始出现）
<ul>
<li>优：提高了资源利用率，多道程序可并发执行</li>
<li>缺：没有人机交互（给操作系统执行一堆命令，你只能选择等待或终止命令）</li>
</ul>
</li>
</ul>
</li>
<li>操作系统阶段
<ul>
<li>分时操作系统
<ul>
<li>优：提供人机交互</li>
<li>缺：不能优先处理紧急任务（对普通用户可忽略，现代分时系统也有程序的优先级之分）</li>
</ul>
</li>
<li>实时操作系统（分软硬实时系统）
<ul>
<li>优：能优先处理紧急任务</li>
</ul>
</li>
<li>两种系统的缺点在其应用领域都不算缺点</li>
</ul>
</li>
</ul>
<h3 id="五-操作系统大内核的功能组成">五、操作系统大内核的功能组成</h3>
<ul>
<li>时钟管理（分配时间片...）</li>
<li>中断处理（并发的前提：不必等到程序运行结束，才能切换程序）</li>
<li>原语（一种不可中断的程序，底层的CPU切换，进程通信...）</li>
<li>对资源进行管理的功能（不直接涉及硬件的功能，微内核不包含）
<ul>
<li>进程管理</li>
<li>存储器管理</li>
<li>设备管理</li>
</ul>
</li>
</ul>
<h3 id="六-运行态和中断机制">六、运行态和中断机制</h3>
<ul>
<li>CPU的运行态
<ul>
<li>内核程序在核心态中执行特权指令和非特权指令（陷入指令除外）</li>
<li>应用程序在用户态中执行非特权指令</li>
</ul>
</li>
<li>操作系统的中断机制
<ul>
<li>作用：中断当前运行的应用程序，CPU由用户态变成核心态，系统内核收回控制权</li>
<li>意义：中断是实现程序并发的前提（微观上，不用等到内存中的程序执行完，就可以切换别的程序）</li>
<li>分类
<ul>
<li>内中断（异常）：与当前执行的指令有关，中断信号源自CPU内部
<ul>
<li>陷入，陷阱</li>
<li>故障</li>
<li>终止</li>
</ul>
</li>
<li>外中断（狭义中断）：与当前执行的指令无关，中断信号源自CPU外部
<ul>
<li>时钟中断（当前程序的时间片用完的时候）</li>
<li>I/O中断请求</li>
</ul>
</li>
</ul>
</li>
<li>执行原理
<ul>
<li>检查中断信号
<ul>
<li>内中断：CPU在执行指令时会检查异常</li>
<li>外中断：每个指令周期末尾，CPU会检查是否有外中断信号待处理</li>
</ul>
</li>
<li>为中断信号找到相应的中断处理程序
<ul>
<li>根据中断信号类型，通过中断向量表，找到处理程序的指针</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="七-系统调用一种特殊的异常">七、系统调用（一种特殊的异常）</h3>
<ul>
<li>系统调用与库函数的区别
<ul>
<li>有的库函数不包含系统调用</li>
<li>有的库函数是对系统调用的封装</li>
</ul>
</li>
<li>什么功能要用系统调用实现
<ul>
<li>涉及共享资源的有关操作</li>
<li>会直接影响其它进程的操作</li>
</ul>
</li>
<li>系统调用的过程
<ul>
<li>传递系统调用参数</li>
<li>用户态下发送系统调用请求：执行陷入指令（trap，访管指令），引起内中断，进入核心态</li>
<li>核心态下处理系统调用</li>
<li>返回应用程序，执行后续指令</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
</feed>