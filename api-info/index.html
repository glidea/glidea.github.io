{"posts":[{"fileName":"pTSnvmBJR","abstract":"","description":"创建线程 创建继承 Thread 类的实例 创建实现 Runnable 接口的实例，注入 Thread 类，或者丢给线程池处理（线程池内部自动创建线程，并启动） 创建实现 Callable 接口的实例，注入 FutureTask...","title":"并发基础","tags":[{"index":-1,"name":"并发","slug":"XShPlIOCO","used":true,"link":"https://glidea.github.io/tag/XShPlIOCO/"}],"feature":"","link":"https://glidea.github.io/post/pTSnvmBJR/","stats":{"text":"4 min read","time":186000,"words":778,"minutes":4},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B\"><strong>创建线程</strong></a></li>\n<li><a href=\"#%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B\"><strong>启动线程</strong></a></li>\n<li><a href=\"#%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B\"><strong>停止线程</strong></a></li>\n<li><a href=\"#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81\"><strong>线程状态</strong></a></li>\n<li><a href=\"#%E6%80%9D%E8%80%83%E9%A2%98\"><strong>思考题</strong></a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2021-01-28 23:06:06","dateFormat":"2021-01-28"},{"fileName":"6vzHvO2bs","abstract":"","description":"类加载（装载）的过程 加载：找到并加载类的二进制流至方法区，并在堆中创建 Class 对象代理，以对方法区对应数据的访问（此阶段由类加载器完成） 链接 验证：校验类是否符合虚拟机的约束 准备：为静态变量分配空间并设置默认值，为所有...","title":"类加载","tags":[{"index":0,"name":"JVM","slug":"eYyARY70R","used":true,"link":"https://glidea.github.io/tag/eYyARY70R/"}],"feature":"","link":"https://glidea.github.io/post/6vzHvO2bs/","stats":{"text":"2 min read","time":110000,"words":518,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%A3%85%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B\"><strong>类加载（装载）的过程</strong></a></li>\n<li><a href=\"#%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%97%B6%E6%9C%BA\"><strong>类初始化的时机</strong></a></li>\n<li><a href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8\"><strong>类加载器</strong></a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2021-01-23 21:25:45","dateFormat":"2021-01-23"},{"fileName":"h1icQUmLi","abstract":"","description":"事务的特性 原子性：事务是由一组SQL组成的逻辑处理单元，要么一起成功，要么一起失败。有undo log(逻辑日志)保证 持久性：事务一旦提交，最终一定会持久化到硬盘（数据先写到内存），不会因为宕机而丢失。有redo log(InnoDB...","title":"事务","tags":[{"index":-1,"name":"MySQL","slug":"4WLNG2urI","used":true,"link":"https://glidea.github.io/tag/4WLNG2urI/"}],"feature":"","link":"https://glidea.github.io/post/h1icQUmLi/","stats":{"text":"4 min read","time":180000,"words":882,"minutes":4},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7\"><strong>事务的特性</strong></a></li>\n<li><a href=\"#%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98\"><strong>事务并发产生的问题</strong></a></li>\n<li><a href=\"#%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E8%AF%BB%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB\"><strong>解决并发读的隔离级别</strong></a></li>\n<li><a href=\"#%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E6%9B%B4%E6%96%B0%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6\"><strong>解决并发更新的锁机制</strong></a></li>\n<li><a href=\"#%E6%80%9D%E8%80%83%E9%A2%98\"><strong>思考题</strong></a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2021-01-23 16:12:03","dateFormat":"2021-01-23"},{"fileName":"kRaswf51Z","abstract":"","description":"对象间的四种引用 强引用：只要 GC Roots 强引用的到，就不会被 GC 回收 软引用：某次 GC 后内存还不够，就把只有软引用的 obj 列入再次 GC 的回收范围 弱引用：如果只有软引用，一旦 GC，就会被回收 虚引...","title":"垃圾回收","tags":[{"index":0,"name":"JVM","slug":"eYyARY70R","used":true,"link":"https://glidea.github.io/tag/eYyARY70R/"}],"feature":"","link":"https://glidea.github.io/post/kRaswf51Z/","stats":{"text":"5 min read","time":291000,"words":1386,"minutes":5},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E5%AF%B9%E8%B1%A1%E9%97%B4%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8\"><strong>对象间的四种引用</strong></a></li>\n<li><a href=\"#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E8%BE%BE\"><strong>判断对象是否可达</strong></a></li>\n<li><a href=\"#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6\"><strong>判断对象是否可以回收</strong></a></li>\n<li><a href=\"#%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95\"><strong>回收算法</strong></a></li>\n<li><a href=\"#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8\"><strong>垃圾收集器</strong></a></li>\n<li><a href=\"#%E6%80%9D%E8%80%83%E9%A2%98\"><strong>思考题</strong></a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2021-01-06 17:22:23","dateFormat":"2021-01-06"},{"fileName":"vwp0rgIpw","abstract":"","description":"虚拟机栈和本地方法栈 栈帧的组成 局部变量表：存放方法参数、局部变量 表item可复用（注意对gc的影响） 这玩意是创建时从运行时常量池弄过来的 操作数栈：类似于数据寄存器，存储临时计算结果 动态连接：当前方法所在类在运...","title":"内存结构","tags":[{"index":0,"name":"JVM","slug":"eYyARY70R","used":true,"link":"https://glidea.github.io/tag/eYyARY70R/"}],"feature":"","link":"https://glidea.github.io/post/vwp0rgIpw/","stats":{"text":"4 min read","time":204000,"words":878,"minutes":4},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88\"><strong>虚拟机栈和本地方法栈</strong></a></li>\n<li><a href=\"#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8\"><strong>程序计数器</strong></a></li>\n<li><a href=\"#%E5%A0%86\"><strong>堆</strong></a></li>\n<li><a href=\"#%E6%96%B9%E6%B3%95%E5%8C%BA\"><strong>方法区</strong></a></li>\n<li><a href=\"#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98\"><strong>直接内存</strong></a></li>\n<li><a href=\"#%E5%8F%82%E8%80%83\"><strong>参考</strong></a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2021-01-06 17:15:37","dateFormat":"2021-01-06"},{"fileName":"qxM2zyb0K","abstract":"","description":"一、程序被装入内存运行前所执行的过程 编译：代码文件 -&gt; 目标模块（高级语言 -&gt; 机器语言） 链接：目标模块 -&gt; 装入模块，此时形成了完整的逻辑地址 静态链接：全部无脑拼凑 装入时动态链接：等到放入内存时，再进行...","title":"操作系统 - 内存管理","tags":[{"index":-1,"name":"操作系统","slug":"rNF1iRjtF","used":true,"link":"https://glidea.github.io/tag/rNF1iRjtF/"}],"feature":"","link":"https://glidea.github.io/post/qxM2zyb0K/","stats":{"text":"5 min read","time":282000,"words":1407,"minutes":5},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E4%B8%80-%E7%A8%8B%E5%BA%8F%E8%A2%AB%E8%A3%85%E5%85%A5%E5%86%85%E5%AD%98%E8%BF%90%E8%A1%8C%E5%89%8D%E6%89%80%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B\">一、程序被装入内存运行前所执行的过程</a></li>\n<li><a href=\"#%E4%BA%8C-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2\">二、操作系统管理内存哪些方面</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2020-06-30 15:04:48","dateFormat":"2020-06-30"},{"fileName":"VuofrILmn","abstract":"","description":"一、进程互斥 实现进程互斥的代码分为 进入区 临界区 退出区 剩余区 进程互斥遵循的原则 空闲让进 忙则等待 有限等待 让权等待：进不了临界区的进程要先放弃处理机，不要干等 进程互斥的软件实现方法 单标志法：傻屌算法 双标志...","title":"操作系统 - 同步","tags":[{"index":-1,"name":"操作系统","slug":"rNF1iRjtF","used":true,"link":"https://glidea.github.io/tag/rNF1iRjtF/"}],"feature":"","link":"https://glidea.github.io/post/VuofrILmn/","stats":{"text":"3 min read","time":142000,"words":698,"minutes":3},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E4%B8%80-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5\">一、进程互斥</a></li>\n<li><a href=\"#%E4%BA%8C-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E5%92%8C%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%85%B3%E7%B3%BB\">二、进程互斥和进程同步的关系</a></li>\n<li><a href=\"#%E4%B8%89-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E5%92%8C%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E7%BB%88%E6%9E%81%E5%BA%95%E5%B1%82%E6%96%B9%E6%A1%88\">三、信号量机制：实现进程互斥和进程同步的终极底层方案</a></li>\n<li><a href=\"#%E5%9B%9B-%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98\">四、经典进程同步和进程互斥问题</a></li>\n<li><a href=\"#%E4%BA%94-%E6%AD%BB%E9%94%81\">五、死锁</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2020-06-22 15:03:27","dateFormat":"2020-06-22"},{"fileName":"4tq--pmpL","abstract":"","description":"一、处理机调度的三个层次 作业调度（高）：从后备队列中选择合适的作业将其从外存调入内存，并为其创建进程 内存调度（中）：从挂起队列中选择合适的进程将其数据从外存调回内存（内存不足时，某些进程会被挂起到外存） 进程调度（低）：从就绪队列中选...","title":"操作系统 - 调度机制","tags":[{"index":-1,"name":"操作系统","slug":"rNF1iRjtF","used":true,"link":"https://glidea.github.io/tag/rNF1iRjtF/"}],"feature":"","link":"https://glidea.github.io/post/4tq--pmpL/","stats":{"text":"5 min read","time":254000,"words":1234,"minutes":5},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E4%B8%80-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E4%B8%89%E4%B8%AA%E5%B1%82%E6%AC%A1\">一、处理机调度的三个层次</a></li>\n<li><a href=\"#%E4%BA%8C-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6\">二、进程调度</a></li>\n<li><a href=\"#%E4%B8%89-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87\">三、调度算法的评价指标</a></li>\n<li><a href=\"#%E5%9B%9B-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95\">四、调度算法</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2020-06-14 14:59:47","dateFormat":"2020-06-14"},{"fileName":"dkeW2P5_b","abstract":"","description":"一、进程和程序有什么区别 程序是静态的，是存储在硬盘的可执行文件，是一系列指令的集合 进程是动态的，是存储在内存中的实体，是程序的一次执行过程 二、进程的组成 PCB：存放操作系统管理进程所需的信息（进程描述信息、进程控制管理信息、资...","title":"操作系统 - 进程","tags":[{"index":-1,"name":"操作系统","slug":"rNF1iRjtF","used":true,"link":"https://glidea.github.io/tag/rNF1iRjtF/"}],"feature":"","link":"https://glidea.github.io/post/dkeW2P5_b/","stats":{"text":"3 min read","time":155000,"words":772,"minutes":3},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E4%B8%80-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\">一、进程和程序有什么区别</a></li>\n<li><a href=\"#%E4%BA%8C-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90\">二、进程的组成</a></li>\n<li><a href=\"#%E4%B8%89-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81\">三、进程的特征</a></li>\n<li><a href=\"#%E5%9B%9B-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F\">四、进程的组织方式</a></li>\n<li><a href=\"#%E4%BA%94-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2\">五、进程的状态与转换</a></li>\n<li><a href=\"#%E5%85%AD-%E5%8E%9F%E8%AF%AD%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E8%A6%81%E5%B9%B2%E7%9A%84%E4%BA%8B%E6%83%85\">六、原语实现进程状态转换要干的事情</a></li>\n<li><a href=\"#%E4%B8%83-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F\">七、进程通信的方式</a></li>\n<li><a href=\"#%E5%85%AB-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B\">八、线程和进程</a></li>\n<li><a href=\"#%E4%B9%9D-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F\">九、线程的实现方式</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2020-06-10 14:58:33","dateFormat":"2020-06-10"},{"fileName":"plMGqezrm","abstract":"","description":"一、操作系统的功能是什么 管理软硬资源：处理机、存储器、设备、文件的管理 向上层提供服务 向用户提供GUI，联机命令接口（单命令），脱机命令接口（批处理bat） 向应用程序提供程序接口（系统调用，广义指令） 对底层功能进行拓展 二...","title":"操作系统 - 基本概念","tags":[{"index":-1,"name":"操作系统","slug":"rNF1iRjtF","used":true,"link":"https://glidea.github.io/tag/rNF1iRjtF/"}],"feature":"","link":"https://glidea.github.io/post/plMGqezrm/","stats":{"text":"4 min read","time":233000,"words":1154,"minutes":4},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E4%B8%80-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88\">一、操作系统的功能是什么</a></li>\n<li><a href=\"#%E4%BA%8C-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81%E6%98%AF%E4%BB%80%E4%B9%88\">二、操作系统的特征是什么</a></li>\n<li><a href=\"#%E4%B8%89-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB\">三、操作系统的特征之间的关系</a></li>\n<li><a href=\"#%E5%9B%9B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E8%83%8C%E6%99%AF%E5%92%8C%E5%88%86%E7%B1%BB\">四、操作系统的发展背景和分类</a></li>\n<li><a href=\"#%E4%BA%94-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%A7%E5%86%85%E6%A0%B8%E7%9A%84%E5%8A%9F%E8%83%BD%E7%BB%84%E6%88%90\">五、操作系统大内核的功能组成</a></li>\n<li><a href=\"#%E5%85%AD-%E8%BF%90%E8%A1%8C%E6%80%81%E5%92%8C%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6\">六、运行态和中断机制</a></li>\n<li><a href=\"#%E4%B8%83-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E5%BC%82%E5%B8%B8\">七、系统调用（一种特殊的异常）</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2020-06-05 14:56:44","dateFormat":"2020-06-05"}],"tags":[{"index":-1,"name":"并发","slug":"XShPlIOCO","used":true,"link":"https://glidea.github.io/tag/XShPlIOCO/","count":1},{"index":0,"name":"JVM","slug":"eYyARY70R","used":true,"link":"https://glidea.github.io/tag/eYyARY70R/","count":3},{"index":-1,"name":"MySQL","slug":"4WLNG2urI","used":true,"link":"https://glidea.github.io/tag/4WLNG2urI/","count":1},{"index":-1,"name":"操作系统","slug":"rNF1iRjtF","used":true,"link":"https://glidea.github.io/tag/rNF1iRjtF/","count":5}],"menus":[{"link":"/","name":"笔记","openType":"Internal"},{"link":"/tags","name":"标签","openType":"Internal"}],"themeConfig":{"themeName":"gridea-theme-pure-master","postPageSize":5,"archivesPageSize":30,"siteName":"Glidea's Note","siteDescription":"","footerInfo":"<h3>懂得越多，会的越少</h3>","showFeatureImage":false,"domain":"https://glidea.github.io","postUrlFormat":"SHORT_ID","tagUrlFormat":"SHORT_ID","dateFormat":"YYYY-MM-DD","feedFullText":false,"feedCount":5,"archivesPath":"archives","postPath":"post","tagPath":"tag"},"customConfig":{"APP_ID":"","APP_KEY":"","about":"","avatar":"","caf":"#84fab0","ccf":"#5f6169","ccs":"#999fa7","ctf":"#343a40","cts":"#272522","customCss":"","descfriend":"","dribbble":"","facebook":"","friends":[],"ga":"","github":"","isEnabledCustomColor":false,"pageSize":"5","placeholder":"Just Go Go","recordIp":false,"skin":"green","twitter":"","vMaxWidth":"1000","vPadding":"2.5%","vPercentWidth":"100","valine":false,"visitor":false,"weibo":"","zhihu":""},"utils":{"now":1612769131442}}
