<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://glidea.github.io</id>
    <title>Glidea&apos;s Blog</title>
    <updated>2020-04-21T13:33:43.313Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://glidea.github.io"/>
    <link rel="self" href="https://glidea.github.io/atom.xml"/>
    <subtitle>be static</subtitle>
    <logo>https://glidea.github.io/images/avatar.png</logo>
    <icon>https://glidea.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Glidea&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[操作系统知识点总结 - 2]]></title>
        <id>https://glidea.github.io/post/cao-zuo-xi-tong-zhi-shi-dian-zong-jie-2/</id>
        <link href="https://glidea.github.io/post/cao-zuo-xi-tong-zhi-shi-dian-zong-jie-2/">
        </link>
        <updated>2020-04-21T13:32:54.000Z</updated>
        <content type="html"><![CDATA[<h4 id="一-进程和程序有什么区别">一、进程和程序有什么区别</h4>
<ul>
<li>程序是静态的，是存储在硬盘的可执行文件，是一系列指令的集合</li>
<li>进程是动态的，是存储在内存中的实体，是程序的一次执行过程</li>
</ul>
<h4 id="二-进程的组成">二、进程的组成</h4>
<ul>
<li>PCB：存放操作系统管理进程所需的信息（进程描述信息、进程控制管理信息、资源分配清单、处理机相关信息）
<ul>
<li>PCB是进程存在的唯一标志</li>
</ul>
</li>
<li>程序段：程序代码（指令集合）</li>
<li>数据段：运行过程中所产生的数据（代码中定义的变量）</li>
</ul>
<h4 id="三-进程的特征">三、进程的特征</h4>
<ul>
<li>动态性（基本特征）</li>
<li>独立性（独立获得资源，独立接受调度的基本单位）</li>
<li>并发性</li>
<li>异步性</li>
<li>结构性</li>
</ul>
<h4 id="四-进程的组织方式">四、进程的组织方式</h4>
<ul>
<li>链接方式：按照进程状态将PCB分为多个队列</li>
<li>索引方式：按照进程状态将PCB分为多个索引表</li>
</ul>
<h4 id="五-进程的状态与转换">五、进程的状态与转换</h4>
<ul>
<li>状态：创建、就绪、运行、阻塞、终止</li>
<li>基本状态之间的转换（原语实现转换的过程）
<ul>
<li>就绪 --》运行：进程被调度</li>
<li>运行 --》就绪：时间片用完，或CPU被高优先级进程抢占</li>
<li>运行 --》阻塞：进程用系统调用的方式，申请系统资源，或者请求等待某个事情的发生（比如其它进程的执行结果）</li>
<li>阻塞 --》就绪：资源已经分配，或者等待的事情发生（被动）</li>
</ul>
</li>
</ul>
<h4 id="六-原语实现进程状态转换要干的事情">六、原语实现进程状态转换要干的事情</h4>
<ul>
<li>更新PCB的信息
<ul>
<li>所有进程控制原语一定会修改进程状态标记</li>
<li>剥夺当前运行进程的CPU使用权，要先保存运行环境，相反进程开始运行前，要恢复运行环境</li>
</ul>
</li>
<li>将PCB插入合适的队列</li>
<li>分配 / 回收资源</li>
</ul>
<h4 id="七-进程通信的方式">七、进程通信的方式</h4>
<ul>
<li>共享存储：互斥访问一块共享空间
<ul>
<li>共享存储的实现可以基于存储区或者数据结构</li>
</ul>
</li>
<li>管道通信：互斥访问一个共享文件（缓冲区）
<ul>
<li>一个管道只能实现半双工通信</li>
<li>写满时，不能再写，读空时，不能再读</li>
<li>没写满，不能读，没读空，不能写</li>
</ul>
</li>
<li>消息传递：进程通过发送 / 接收原语来 发送 / 接收结构化的消息（消息头/消息体）
<ul>
<li>直接通信：消息直接挂到接收线程的消息队列里</li>
<li>间接通信：消息发送到公共信箱</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[三门问题]]></title>
        <id>https://glidea.github.io/post/san-men-wen-ti/</id>
        <link href="https://glidea.github.io/post/san-men-wen-ti/">
        </link>
        <updated>2020-04-19T02:50:36.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1-什么是三门问题">1、什么是三门问题</h4>
<p>​		三门问题出自美国的电视游戏节目Let's Make a Deal。参赛者会看见三扇关闭了的门，其中一扇的后面有一辆汽车，选中后面有车的那扇门可赢得该汽车，另外两扇门后面则各藏有一只山羊。当参赛者选定了一扇门，但未去开启它的时候，节目主持人开启剩下两扇门的其中一扇，露出其中一只山羊。主持人其后会问参赛者要不要换另一扇仍然关上的门。</p>
<p>​		<strong>问题是换门后会不会增加中奖概率？</strong></p>
<h4 id="2-答案是个啥">2、答案是个啥？</h4>
<p>​		相信你直觉上的答案是 “换门不会增加中奖概率”</p>
<p>​		但是<strong>正确答案是换门可以增加中奖概率</strong></p>
<p>​		你是不是觉得这个答案很奇怪，很反直觉，内心有一万个不服？</p>
<p>​		于是你去看了下这个问题的数学证明</p>
<p>​		心想，好像是这样子哦！</p>
<p>​		但是你眉头一皱，总感觉哪里不对劲</p>
<p>​		对数学证明的态度在好像明白和质疑之间反复横跳</p>
<p>​		那既然你对直觉和数学证明都不太相信的话，那我们就用另外的方式去求解一下这个答案！</p>
<h4 id="3-计算机模拟求解的思路">3、计算机模拟求解的思路</h4>
<p>​		用程序怎么解决这个问题呢？</p>
<p>​		直接套概率公式，让计算机给你解计算题？？这样的话不就是相当于我们把上面的正确答案，用计算机复述了一遍吗</p>
<p>​		正确思路是，我们要假设自个参加了一百万次这个节目，并面临了同样的选择，并且并且我一定要换门。看看我这一百万次，能中多少次奖，进而求出换门的中奖率。然后我又参加一百万次，但这一百万次我要坚持不换门，看看我这一百万次，能中多少次奖，进而求出不换门的中奖率。</p>
<p>​		讲到这里思路很明显了，我们要用计算机模拟数百万次这种场景，进而得出答案。</p>
<h4 id="4-计算机模拟的代码">4、计算机模拟的代码</h4>
<pre><code class="language-java">public class Solution {
    private static int N = 100000;// 模拟场景的次数

    // 计算选择N次 换门或者不换门 的整体中奖概率
    private static double getProbability(boolean changeDoor) {
        int winTimeCount = 0;

        for (int i = 0; i &lt; N; i++)
            if (choice(changeDoor))
                winTimeCount++;

        return (double) winTimeCount / N;
    }

    // 模拟 选择换门或者不换门 是否能中奖
    private static boolean choice(boolean changeDoor) {
        int firstChoice = (int) (Math.random() * 3);
        int prizeDoor = (int) (Math.random() * 3);

        // 要理解这里，需要明白，本来只有三个门，主持人已经把一个没有奖品的门给开了
        // 只剩下两个门给你选，如果你本来选的门没有奖品，换门一定拿奖，反之亦然
        if (firstChoice == prizeDoor) {
            return changeDoor ? false : true;
            // 上面的语句可以写成：return !changeDoor;
            // 为了语义清晰，写成了三目表达式的形式，下面else里的return语句也是类似的
        } else {
            return changeDoor ? true : false;
        }
    }

    public static void main(String[] args) {
        System.out.println(&quot;换门 - 中奖的概率：&quot; + getProbability(true));
        System.out.println(&quot;不换门 - 中奖的概率：&quot; + getProbability(false));
    }
}
</code></pre>
<p><strong>运行结果：</strong></p>
<pre><code>换门 - 中奖的概率：0.66731
不换门 - 中奖的概率：0.33346
</code></pre>
<h4 id="5-为什么答案是会增加中奖概率呢">5、为什么答案是会增加中奖概率呢</h4>
<p>​		至此，答案已经很明显了，但是你可能还是不太明白这个答案，所以在此我给出一个不严谨的解释</p>
<p>​		假设选择换门，而现在选择的门后面没有奖品，所以必定中奖（只有一个门可以换）</p>
<p>​		假设选择换门，而现在选择的门后面有奖品，所以必定不中奖</p>
<p>​		而选择的门后没有奖品的概率是2 / 3</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统知识点总结 - 1]]></title>
        <id>https://glidea.github.io/post/cao-zuo-xi-tong-zhi-shi-dian-zong-jie-1/</id>
        <link href="https://glidea.github.io/post/cao-zuo-xi-tong-zhi-shi-dian-zong-jie-1/">
        </link>
        <updated>2020-04-17T12:17:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-操作系统的功能是什么">一、操作系统的功能是什么</h3>
<ul>
<li>管理软硬资源
<ul>
<li>处理机管理</li>
<li>存储器管理</li>
<li>文件管理</li>
<li>设备管理</li>
</ul>
</li>
<li>向上层提供服务
<ul>
<li>向用户提供GUI，单命令（联机命令接口），批处理（脱机命令接口）</li>
<li>向应用程序提供程序接口（系统调用）</li>
</ul>
</li>
<li>对底层功能进行拓展</li>
</ul>
<h3 id="二-操作系统的特征是什么">二、操作系统的特征是什么</h3>
<ul>
<li>并发：一个时间段内，多件事情在宏观上同时发生，在微观上交替发生</li>
<li>共享（并发的条件）
<ul>
<li>互斥共享：一个资源，一个时间段内只允许一个进程访问</li>
<li>同时共享：一个资源，一个时间段内允许多个进程访问</li>
</ul>
</li>
<li>虚拟：一个物理实体（硬盘）--》若干个虚拟逻辑体（C盘、D盘...）</li>
<li>异步：在资源有限的情况下，并发执行的多个程序的执行，总是走走停停的（不按代码的顺序执行）</li>
</ul>
<h3 id="三-操作系统的特征之间的关系">三、操作系统的特征之间的关系</h3>
<ul>
<li>并发和共享互为存在条件
<ul>
<li>没有共享，无法实现并发</li>
<li>没用并发，共享就没有意义</li>
</ul>
</li>
<li>并发和共享是虚拟的前提条件
<ul>
<li>共享是并发的前提，而并发是虚拟性<strong>存在意义的前提</strong></li>
</ul>
</li>
<li>并发和共享必然导致异步</li>
</ul>
<h3 id="四-操作系统的发展背景和分类">四、操作系统的发展背景和分类</h3>
<ul>
<li>手工操作阶段（手工输入一条条指令）
<ul>
<li>缺：人机速度矛盾（人工太tm慢了，机器等得很不耐烦）</li>
</ul>
</li>
<li>批处理阶段
<ul>
<li>单道批处理系统（引入脱机输入输出技术）
<ul>
<li>优：缓解了人机速度矛盾</li>
<li>缺：内存中只有一道程序执行，资源利用率还是很低（每次只有一个进程走流程，没走到的部分只能干等着）</li>
</ul>
</li>
<li>多道批处理系统（操作系统开始出现）
<ul>
<li>优：提高了资源利用率，多道程序可并发执行</li>
<li>缺：没有人机交互（给操作系统执行一堆命令，你只能选择等待或终止命令）</li>
</ul>
</li>
</ul>
</li>
<li>操作系统阶段
<ul>
<li>分时操作系统
<ul>
<li>优：提供人机交互</li>
<li>缺：不能优先处理紧急任务（对普通用户可忽略，现代分时系统也有程序的优先级之分）</li>
</ul>
</li>
<li>实时操作系统（分软硬实时系统）
<ul>
<li>优：能优先处理紧急任务</li>
</ul>
</li>
<li>两种系统的缺点在其应用领域都不算缺点</li>
</ul>
</li>
</ul>
<h3 id="五-操作系统大内核的功能组成">五、操作系统大内核的功能组成</h3>
<ul>
<li>时钟管理（分配时间片...）</li>
<li>中断处理（并发的前提：不必等到程序运行结束，才能切换程序）</li>
<li>原语（一种不可中断的程序，底层的CPU切换，进程通信...）</li>
<li>对资源进行管理的功能（不直接涉及硬件的功能，微内核不包含）
<ul>
<li>进程管理</li>
<li>存储器管理</li>
<li>设备管理</li>
</ul>
</li>
</ul>
<h3 id="六-运行态和中断机制">六、运行态和中断机制</h3>
<ul>
<li>CPU的运行态
<ul>
<li>内核程序在核心态中执行特权指令和非特权指令（陷入指令除外）</li>
<li>应用程序在用户态中执行非特权指令</li>
</ul>
</li>
<li>操作系统的中断机制
<ul>
<li>作用：中断当前运行的应用程序，CPU由用户态变成核心态，系统内核收回控制权</li>
<li>意义：中断是实现程序并发的前提（微观上，不用等到内存中的程序执行完，就可以切换别的程序）</li>
<li>分类
<ul>
<li>内中断（异常）：与当前执行的指令有关，中断信号源自CPU内部
<ul>
<li>陷入，陷阱</li>
<li>故障</li>
<li>终止</li>
</ul>
</li>
<li>外中断（狭义中断）：与当前执行的指令无关，中断信号源自CPU外部
<ul>
<li>时钟中断（当前程序的时间片用完的时候）</li>
<li>I/O中断请求</li>
</ul>
</li>
</ul>
</li>
<li>执行原理
<ul>
<li>检查中断信号
<ul>
<li>内中断：CPU在执行指令时会检查异常</li>
<li>外中断：每个指令周期末尾，CPU会检查是否有外中断信号待处理</li>
</ul>
</li>
<li>为中断信号找到相应的中断处理程序
<ul>
<li>根据中断信号类型，通过中断向量表，找到处理程序的指针</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="七-系统调用一种特殊的异常">七、系统调用（一种特殊的异常）</h3>
<ul>
<li>系统调用与库函数的区别
<ul>
<li>有的库函数不包含系统调用</li>
<li>有的库函数是对系统调用的封装</li>
</ul>
</li>
<li>什么功能要用系统调用实现
<ul>
<li>涉及共享资源的有关操作</li>
<li>会直接影响其它进程的操作</li>
</ul>
</li>
<li>系统调用的过程
<ul>
<li>传递系统调用参数</li>
<li>用户态下发送系统调用请求：执行陷入指令（trap，访管指令），引起内中断，进入核心态</li>
<li>核心态下处理系统调用</li>
<li>返回应用程序，执行后续指令</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
</feed>